1.快速幂思想----剑指 Offer II 001. 整数除法
          ----372. 超级次方
——————————————————————————————————————


2.滑动窗口 or 双指针 (埋坑题)----567. 字符串的排列
—————————————————————————————————————
方法  Arrays.equals()
优化后的动态窗口方法太强了 双数组太强了
我愿称它为埋坑题


3.中序遍历二叉树----94. 二叉树的中序遍历
————————————————————————————————————
递归法（能写了）
迭代法！
Morris 中序遍历 ！！！

4.埋坑 位运算 写法----剑指 Offer II 005. 单词长度的最大乘积
————————————————————————————————————————————————————————
用二进制来标识字符串所用到的字符  也算埋坑题了吧
还涉及未常见方法:
HashMap.keySet()
HashMap.getOrDefault()


5.BFS----116. 填充每个节点的下一个右侧节点指针
——————————————————————————————————————————————————————————
DFS 实现方法: 递归 栈
BFS 实现方法: 队列
（用栈和队列的就不用递归了，直接while（非空）循环即可）
还有一个好用的next指针法


6.降序排序----506. 相对名次(有涉及)
————————————————————————————————————————————————————————————————————————
1.Arrays.sort(arr,Collections.reverseOrder());         arr是Integer的数组!
2.利用Comparator接口复写compare
代码:
      public class Main {
          public static void main(String[] args) {
              Integer[] arr={9,8,7,6,5,4,3,2,1};
              Comparator cmp=new CMP();
              Arrays.sort(arr,cmp);   //降序排序
          }
      }
      class CMP implements Comparator<Integer>{
          @Override //可以去掉。作用是检查下面的方法名是不是父类中所有的
          public int compare(Integer a,Integer b){
      //        两种都可以，升序排序的话反过来就行
      //        return a-b<0?1:-1;
              return b-a;
          }
      }
3.Arrays.sort(ages,(a,b)->b-a); 要是Integer[]

7.DFS或BFS地图染色机制----733. 图像渲染
——————————————————————————————————————————————
虽然方法是有返回值的 但不一定要接收！！！！
我之前一直提前考虑怎么处置有返回值的方法的返回值
现在才知道了不一定要接收它
(等等，我试了试，怎么好像在if哪里才可以不要返回值的)(存疑)

8.统计字符串也可以埋坑法----383. 赎金信
————————————————————————————————————————————————

9.全排列（A）----剑指 Offer 38. 字符串的排列
       ----46. 全排列
————————————————————————————————————————————————————
这个非常重量级
全排列DFS写法
还要注意 46. 全排列 里遇到的大坑
Collections.swap()方法
(顺便说 如果不是全排列 而是几个数的排列 那就调整结束条件就好了(取前几层))

10.组合(C)----77. 组合
————————————————————————————————————————
ohhhhhh 可以把它和全排列一起看了
组合是不能有“重复但顺序不同的“
虽然可以用全排列的方法加上Set<Set<Integer>> sets = new HashSet<>(); 找出组合
但效率太低了
我相信我记得住这个方法的 过了

11.二叉树的最近公共祖先                   ----剑指 Offer 68 - II. 二叉树的最近公共祖先
   (DFS递归自下而上计数(层数))
   (DFS从根节点出发记录路径)              ----5944. 从二叉树一个节点到另一个节点每一步的方向(270周赛)
————————————————————————————————————————————————————————————————————————————————————————
好用 自下而上的
5944. 从二叉树一个节点到另一个节点每一步的方向(270周赛) 还有很常用的方法类型


12.TreeSet类----5942. 找出 3 位偶数(270周赛)
————————————————————————————————————————————————————————
TreeSet是一个有序的集合，它的作用是提供 有序的Set 集合。（有序且不重复）
另外 还有加上泛型<>后，从集合中取数据就不是Object了 不用再强转了

13.BFS及DFS超级应用
    生化危机之Rotten Orange----994. 腐烂的橘子
    边界问题----1034. 边界着色
——————————————————————————————————————————————————
费了好大劲 好歹自己写出了
好好看看答案的思路

14.动态规划困难版 三个变量----689. 三个无重叠子数组的最大和
————————————————————————————————————————————————
第一题困难题


15.二分查询对边界问题的应用----34. 在排序数组中查找元素的第一个和最后一个位置
                        ----剑指 Offer 53 - I. 在排序数组中查找数字 I
——————————————————————————————————————————————————————————————————
 用
 while (i<=j){
               int t = i+(j-i)/2;
               if(nums[t]<=target) i=t+1;
               else j=t-1;
           }
   结束后它会到目标数字的右边第一位非目标数字
   若要找两个边界或目标数字们的长度 就把target-1 (或target-0.5)
   求比原target小一点的数（不用管它存不存在）的边界值
   用两个边界值来解决即可

而用官方的方法 也可以使这本会找右边界的右一位的方法
变成了 找到左边界的左一位的方法

另外 对空int数组来说 判断为空可以用 nums.length==0

16.动态规划之三角形最小路径和----120. 三角形最小路径和
————————————————————————————————————————————————————

17.方法 String.toLowerCase()把字符都变成小写的 有返回值的！
不能 string.toLowerCase()
而是 string=string.toLowerCase()
方法String.toUpperCase()把小写变大写也一样

方法Character.isLetter()判断是否为字符  Character还有类似方法

                                        ----748. 最短补全词

18.二分查询高能应用之细节魔鬼
                                ----33. 搜索旋转排序数组
——————————————————————————————————————————————————————
 int m = l + (r - l + 1) / 2;
 //这里很妙 相当于  m = l + (r - l)/2 + 1/2  当m卡中间时,会偏向右边


19.字符char可以对数字运算，是ascall码运算
                                ----709. 转换成小写字母
 ——————————————————————————————————————————————————————



 20.二维数组的二分查找
                    ----74. 搜索二维矩阵
 ————————————————————————————————————————————————————————————

 21.二分查找之两个断坡
                    ----153. 寻找旋转排序数组中的最小值
 ————————————————————————————————————————————————————————————————

22.贪心困难题 上了9年的课
                    ----630. 课程表 III
——————————————————————————————————————————————————————
注意 自定义排序的写法

23.深度优先搜索 图 拓扑排序 数组
                        ----851. 喧闹和富有
————————————————————————————————————————————————————————————
高能

24.爬坡法 二分爬坡法
                        ----162. 寻找峰值
——————————————————————————————————————————————————————————————
特邀方法 Math.random() 取随机值
可以这么用  int idx = (int) (Math.random() * n);

25.求解最长递增子序列（的长度）
                        ----2111. 使数组 K 递增的最少操作次数(272周赛)
                        300. 最长递增子序列
——————————————————————————————————————————————————————————————
注意，只可以求长度，方法最后得到数组链表里不是最长递增子序列


26.KMP算法
                        ----28. 实现 strStr()
                        ----686. 重复叠加字符串匹配
————————————————————————————————————————————————————————————————————————————————————————————————————————————
非常重要
https://www.bilibili.com/video/BV1Px411z7Yo?from=search&seid=12619944045340560478&spm_id_from=333.337.0.0
https://www.bilibili.com/video/BV1jb411V78H?from=search&seid=12619944045340560478&spm_id_from=333.337.0.0


27.求交集                  ----986. 区间列表的交集
——————————————————————————————————————————————————————————————————————————————————————————————————
重点： 1.求交集的方法
      2.灵活应用修改二维数组:
      用ArrayList<int[]> ans = new ArrayList<>();
      写入ans.add(new int[]{});
      转为二维数组 ans.toArray(new int[ans.size()][]);

28.动态承水问题（我的命名）   ----11. 盛最多水的容器
————————————————————————————————————————————————————————


29.Rabin-Karp 字符串编码 重要       ----1044. 最长重复子串
——————————————————————————————————————————————————————————————
高能高难 我还没看懂


30.二维数组绕圈问题                 ----1041. 困于环中的机器人
————————————————————————————————————————————————————————————————————-
一次指令之后，只有(x,y)不是原点，并且方向和原来的方向一致，最后才回不去
//如果一次指令后，不在原点，但方向于原来不同，哪这之后多绕几圈也会回去的
重点:
1.规律
2.原点的判断方法（数组）
非原点: (L[0]!=0&&L[1]!=0)||(L[0]+L[1]!=0)
============================================
3.方向可以:
int d = 0; // 四个方向 0上1右2下3左  这样定是为了满足 d+1就是向左转 d+3就是向右转


31.大名鼎鼎的三数之和                ----15. 三数之和
————————————————————————————————————————————————————————————————————————————
多看看看看!
重点:排序 + 双指针
也是两层遍历 最后一个顺应前两者的要求而变 就是双指针


32.优先队列                         ----1705. 吃苹果的最大数目
————————————————————————————————————————————————————————————————
另外
int[] arr = pq.peek();
这里很重要 是替身攻击！！！  int[] arr = pq.peek(); 可以让int[] arr代理pg.peek()


33.有点出奇的DFS和BFS题
                                                    ----130. 被围绕的区域
——————————————————————————————————————————————————————————————————————————————————————————
1.注意 if(DFS(bo,i+1,j,b,isb)|DFS(bo,i-1,j,b,isb)|DFS(bo,i,j+1,b,isb)|DFS(bo,i,j-1,b,isb)|(isb))
用的是 | !!!!
||是左边true就不搞右边了
| 不管结果，两边都搞
同理
&&是左边false就不搞右边了
&是| 不管结果，两边都搞
就如同while里面要判断边界的条件话一定放左边
一定要注意 尤其是这种要并列返回boolean的方法的判断

2.对边界的遍历方式
n = board.length;
m = board[0].length;
for (int i = 0; i < n; i++) {

        }
for (int i = 1; i < m - 1; i++) {

        }


34.回朔 求全子集!            ----78. 子集（不含重复数字）
                            ----90. 子集 II （含重复数字）
————————————————————————————————————————————————--
两种方法都很强
思路一： 好强 利用已经放进去的结果进行不断的累积
nums={1，2，3}
0                放一个空的 这里用0代替空
01               j=0,取出nums[j]=1 得(0+1=01)
02 012           j=1,取出nums[j]=2 得(0+2=02 01+2=012)
03 013 023 0123  j=2,取出nums[j]=3 得(0+3=03 01+3=013 02+3=023 012+3=0123)
思路二：
这题好逆天 我拿草稿推了一遍才懂 不愧是回溯题
好吧 又理了一下 变清晰了
它就如同二叉树一般 每层分为两步：
 考虑选择当前位置
 考虑不选择当前位置

 35.环形的动态规划问题               ----213. 打家劫舍 II
 ————————————————————————————————————————————————————————
 1.思路 把环分成两节
 把[0,n-1] 断成 [0,n-2]与[1,n-1] 分别动态规划再取大的就行

 2.大佬的动态规划方法

 3.取子数组方法!!!  Arrays.copyOfRange(int[] nums,int start,int end) 左闭右开


 36.单词查字典/单词拆分/动态规划拆单词               ----139. 单词拆分
 ————————————————————————————————————————————————————————————————


37.前缀和 后缀和                  ----5965. 相同元素的间隔之和（273周赛）
——————————————————————————————————————————————————————————————————

38.计数排序 + 前缀和                               ----825. 适龄的朋友
——————————————————————————————————————————————————————————————————


39. 对HashMap的灵活操作           ----1296. 划分数组为连续数字的集合


40.(一维/二维)数组复制方法                   ----2022. 将一维数组转变成二维数组
————————————————————————————————————————————————————————————————————
方法:
arraycopy(Object src, int srcPos, Object dest, int destPos, int length)
          从指定源数组中复制一个数组，复制从指定的位置开始，到目标数组的指定位置结束。
          从src的下标srcPos到srcPos+length 复制到 dest 的 destPos 到 destPos+length 处
          length是公用的

41.空节点啊空节点                          ----剑指 Offer II 021. 删除链表的倒数第 n 个结点
——————————————————————————————————————————————————————————————————————————————————————
考试几天没写题了 又好久没写指针了 技巧都忘了 特此提醒:
如果在写题时发生了空指针异常 编程生涯就结束了吧
对了,那就就建立很强的空节点掩盖过去吧
listnode~listnode~listnode~listnode~listnode~

42.含环链表:找环的入口节点             ----剑指 Offer II 022. 链表中环的入口节点
————————————————————————————————————————————————————————————————————————

43.两个链表的第一个重合节点            ----剑指 Offer II 023. 两个链表的第一个重合节点

44.重排链表之寻找链表中点 + 链表逆序 + 合并链表                ----剑指 Offer II 026. 重排链表
   链表丢数组                                             ----剑指 Offer II 026. 重排链表  ----剑指 Offer II 027. 回文链表       ----234. 回文链表

45.模拟等差数列                       ----390. 消除游戏

46.把字符串转为对应的26位二进制数             ----2135. 统计追加字母可以获得的单词数(第275场周赛vika维格)

47.滑窗妙啊                         ----2134. 最少交换次数来组合所有的 1 II(第275场周赛vika维格)

48.贪心思想                             ----334. 递增的三元子序列

49.取随机数                         ----382. 链表随机节点
    水塘抽样算法!!!!                  ----382. 链表随机节点  ---398. 随机数索引
————————————————————————————————————————————————————————————————————————————
1.方法Math.random()取[0,1)
2. // int rand = (int)Math.random()*arrayList.size();  不行 这样(int) 只强转前面那个
      要  int rand = (int)(Math.random()*arrayList.size());
   ================================================================
   水塘抽样算法:
   从链表头开始，遍历整个链表，对遍历到的第 i 个节点，随机选择区间 [0,i)内的一个整数，如果其等于0，则将答案置为该节点值，否则答案不变。
   该算法会保证每个节点的值成为最后被返回的值的概率均为 1/n
   注意:  Random random = new Random();


50.博弈                               ----2029. 石子游戏 IX

51.BFS不明显应用                     ----1345. 跳跃游戏 IV

52.优先队列/优先队列中如何解决重复问题不理解           ---- 373. 查找和最小的 K 对数字
——————————————————————————————————————————————————————————————————————————————————-
方法：
构造优先队列示例
PriorityQueue<int[]> pq = new PriorityQueue<>(k, (o1, o2)->{
             return nums1[o1[0]] + nums2[o1[1]] - nums1[o2[0]] - nums2[o2[1]];
            //其实就是 return ((nums1[o1[0]] + nums2[o1[1]]) - (nums1[o2[0]] + nums2[o2[1]]));
        });


用优先队列吧
先说难点1:
就是构造比较方式
int[] 第一个是放num1的下标 第二个是放num2的下标
o1 o2 各自代表一个int[] 要比较它们 就是写 return ((nums1[o1[0]] + nums2[o1[1]]) - (nums1[o2[0]] + nums2[o2[1]]));

难点2:
详细见：
https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/solution/cha-zhao-he-zui-xiao-de-kdui-shu-zi-by-l-z526/
https://leetcode-cn.com/problems/find-k-pairs-with-smallest-sums/solution/bu-chong-guan-fang-ti-jie-you-xian-dui-l-htf8/
可以用下面的 “另一版本” 它用双重遍历把所有的可以的下标都放进来了
用Math.min() 比较与k的关系 这样不至于像我一开始写的那样超内存
但仍然有大量浪费
用官方的方法先存下标 (0,0) (1,0) (2,0) ... (Math.min(m,k),0)
放入优先队列后会自动排序 先取出下标(0,0)后 [因为num1 num2 是拍好序的 第一个取的就会是(0,0)] 再放入（0,0+1） 放入后又会自己调整排序 以此类推 这样就非常高效了
（总之啊 若画出下标图 答案一般都在左上角 和 上、左边界的 用这种方法就是为了更快的关联起来[取出下标组后再放入相应的(难点2) 就关联得快了]）

53.栈的隐藏应用（即要自己联想到用栈）        ----剑指 Offer II 038. 每日温度
————————————————————————————————————————————————————————————————————
我是用队列Deque模拟栈 注意了 peek() 和 offer()都是队列的 要改成peekLast()和pollLast()

 总之 ArrayDeque类 若用栈 ： 看顶值peek() 压栈push() 出栈pop()   它们都是相当于对头部元素操作的（就是对队列的头 而不是尾）
 若用队列 就用别的 不要混着用
 如  pop()相当poll()  pop()是操作栈的 poll()是操作队列的  但其实一样 都取头元素
 总之 用ArrayDeque类模拟栈就相当于用双端队列的头部来模拟栈 pop() //得到的是头部元素 push() //插入的也是头部



54.有个简单的位运算(常用)             ----1688. 比赛中的配对次数
——————————————————————————————————————————————————
简单的题
也有要注意的
1. 是n！=1
2. if((n&1)==0) 用位运算是要括号的 应该是优先级问题

括号括号括号！！！


55.大数相加！！！！             ----2. 两数相加
————————————————————————————————————————————————————
//求助BigInteger类 成了
注意BigInteger是用add()来两数相加的
sb.append(可以放BigInteger)
记得在力扣中用的话 要导入import java.math.BigInteger;

56.遍历回溯(有几层要回溯 每层又有多个数（要遍历）)            ----17. 电话号码的字母组合
——————————————————————————————————————————————————————————————————————————————
HashMap还有这种构造方法 : HashMap(Map<? extends K,? extends V> m)
 Map<Character, String> phoneMap = new HashMap<Character, String>() {{
            put('2', "abc"); //要放入的值
            put('3', "def");
            put('4', "ghi");
            put('5', "jkl");
            put('6', "mno");
            put('7', "pqrs");
            put('8', "tuv");
            put('9', "wxyz");
        }};

注意：leetcode永远会存在输入为空的情况，这也是我没有考虑到的


57.回文串判定！之 动态规划!!!                          ----5. 最长回文子串
——————————————————————————————————————————————————————————————————————
对于一个子串而言，如果它是回文串，并且长度大于 22，那么将它首尾的两个字母去除之后，它仍然是个回文串。
例如对于字符串“ababa”，如果我们已经知道“bab” 是回文串，那么“ababa” 一定是回文串，这是因为它的首尾两个字母都是“a”
即如果 “ababa”首尾都是“a” 那么 “ababa”是否为回文 相当于 “bab”是否为回文  继续推到底 所有长度为 1 的子串都是回文串（“a”）

58.括号生成(回溯)                                         ----22. 括号生成
——————————————————————————————————————————————————————————————————
简单而复杂

59.哈希表的高级应用（二维坐标图与其关联）    遍历哈希表！！！!           ----2013. 检测正方形
                                                                ----884. 两句话中的不常见单词
——————————————————————————————————————————————————————————————————
还有
新的用法出现了！！！
遍历哈希表！！！! 是遍历 映射关系 是把k和v一对拿出来
for (Map.Entry<Integer, Map<Integer, Integer>> map : cnt.entrySet())
然后用 map.getValue() map.getKey() 方法
!!!!!

 Map<Integer, Map<Integer, Integer>> cnt;
 Set<Map.Entry<Integer, Map<Integer, Integer>>> entries = cnt.entrySet();
 for (Map.Entry<Integer, Map<Integer, Integer>> entry : entries) {}
 //即是 for (Map.Entry<Integer, Map<Integer, Integer>> entry : cnt.entrySet()) {}
  Map<Integer, Integer> colCnt = entry.getValue();
  虽然也不一定要用

不过这不是重点 重点还是二重哈希表

搞了半天啊

60.二维数组排序断层问题                           ----1996. 游戏中弱角色的数量
——————————————————————————————————————————————————————————————————————
(对二维数组按第一个数排序 当第一个数相同时 会被排在一起 我称它们为断层)

排序方法！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！
学到了！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！

对 int[] o1 , int[] o2
先判断 o1[0] == o2[0]?  若不等 当然先按第一个数的大小排序 (o1[1] - o2[1])
                        若相等 形成断层 同一层内 第一个数相同 那么就按第二个数排序 (o2[0] - o1[0])

在下面一个例子 是按照第一个从大到小 若第一个数相同 那么按第二个数从小到大   主要是看谁减谁（主要看返回的是正数还是负数） 这个我懂的
public int numberOfWeakCharacters(int[][] properties) {
Arrays.sort(properties, (o1, o2) -> {
            return o1[0] == o2[0] ? (o1[1] - o2[1]) : (o2[0] - o1[0]);
        }); }


61.BFS多点同时出发问题(不要局限于一点)             ----1765. 地图中的最高点
——————————————————————————————————————————————————————————————————————————
官方答案
 cao 发现题目看误了 不过这和我的思路好像没有冲突 也和我的超时无关 况且都已经44/59了
 看懂了 是我被过去束缚住了
 我的方法是从每个个点单独出发 而这对本题来说太耗时了 还要解决冲突
 应该是多点同时出发
 当然我一开始也是想过同时出发的 但脑子就是没想过把点先一起放入队列中
 也许是觉得还要先遍历一次太不优雅了

 ！！！总之 BFS 从一点出发 就只先放一点入队列 然后while (!queue.isEmpty())循环
           从多点出发 就把这些点都放到队列(先遍历一遍 顾不上优雅了) 再while (!queue.isEmpty())循环

 另外注意:
 int[][] ans = new int[m][n];
         for (int i = 0; i < m; ++i) {
             Arrays.fill(ans[i], -1); // -1 表示该格子尚未被访问过
         }

  不可以 Arrays.fill(ans, -1); // 二维数组直接这样是达咩的


62.(重量级)  哈希表 + 双向链表 （哈希的值串成链表/哈希指向链表的各个节点）         ----146. LRU 缓存
——————————————————————————————————————————————————————————————————————————————————————————
非常有意思的一题
长话短说 就是  哈希表 + 双向链表
要好好好好地理清它们的关系
两者独立又有关联
构造一个双向链表 也就是写一个可以双向的节点
class DLinkedNode {
        int key;
        int value;
        DLinkedNode prev;
        DLinkedNode next;
        public DLinkedNode() {}
        public DLinkedNode(int _key, int _value) {key = _key; value = _value;}
    }
把节点们相连就是链表，双向链表
这个节点有key 又有value
然后 又把key作为键 节点DLinkedNode为值 构造哈希表
注意注意注意注意 哈希是 映射 关系
节点们并不是拆开放入哈希的 ！！！ 节点们依然是上下串联着的 构成双向链表的 ！！！
哈希只是映射关系 节点们不分散
基于这种数据结构来实现本题 可以通过哈希映射来找到相应节点 节点们不分散 是上下连着的 我们就可以直接对着这个节点操作
所以要摆脱哈希的固有印象 认识到哈希是映射 可以快速查询 查询到的对象不是独立的 他们不是一定为了哈希才放进 而是它们在各个地方 为了好找 才有的哈希
说多了 总之 哈希不是箱子 是线
好好看看 好好理清它
=========================================================
另外 其实不需要手写本题 已有封装类了 不懂就算了
是 LinkedHashMap
本题答案 (用LinkedHashMap)
class LRUCache extends LinkedHashMap<Integer, Integer>{
    private int capacity;

    public LRUCache(int capacity) {

        super(capacity, 0.75F, true); //super(参数)：调用父类中的某一个构造函数（应该为构造函数中的第一条语句）。
        //即搞这个 LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) 构造一个空的 LinkedHashMap实例，具有指定的初始容量，负载因子和订购模式。
        this.capacity = capacity;
    }

    public int get(int key) {
        return super.getOrDefault(key, -1);
    }

    public void put(int key, int value) {
        super.put(key, value);
    }

    //这个应该是它内部的要用 //见jdk
    @Override
    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
        return size() > capacity;
    }
}

63.正方形矩阵 旋转90度                          ----48. 旋转图像
——————————————————————————————————————————————————————————————
死记
1.方法一 数学法
  顺时针 一下是顺时针的方法 其他方向自己修改
  记就完事了 考虑四个角 和它们接下来的走向
  (若第一组是左上角(0,0) 它转到（0，n-1） 则下一组就是（0，1） 到 （1，n-1）  那么第一组是（0，0） 第二组是（0，1） 就是i不变 j变 ；看看对应的 （0，n-1）和 （1，n-1）)
  （我们就猜出了matrix[i][j]=matrix[n-j-1][i]; 但当j变i不变时 [n-j-1]变 而 [i] 不变）
  看 横 纵 那个变 那个不变
  然后 把 i j n-i-1 n 一一放入 就那么几个

2.方法二 用翻转代替旋转
  顺时针旋转  相当于  水平翻转（上下翻）+主对角线翻转

3.用方法一：使用辅助数组 low

64.取一组数的全排列中的某种排列的下一个更大的排列              ----31. 下一个排列
————————————————————————————————————————————————————————————————————————————
如1,2,3 组成的排列 有123 132 213 231 312 321 对132来说 下一个更大的是213

https://leetcode-cn.com/problems/next-permutation/
关键是思路 代码不难
注意到下一个排列总是比当前排列要大，除非该排列已经是最大的排列。
我们希望找到一种方法，能够找到一个大于当前序列的新序列，且变大的幅度尽可能小。
我们需要将一个左边的「较小数」与一个右边的「较大数」交换，以能够让当前排列变大，从而得到下一个排列。
同时我们要让这个「较小数」尽量靠右，而「较大数」尽可能小。当交换完成后，「较大数」右边的数需要按照升序重新排列。这样可以在保证新排列大于原来排列的情况下，使变大的幅度尽可能小。

总结： 从右往左 找第一个不参与递增的i(指下标) 再从右往左 找找到了最小的一个比i大的j 互换(下标i还是i j还是j) 再把右边的全都 升序排序


65.回溯套循环!!!                ----39. 组合总和
——————————————————————————————————————————————————
见大佬代码！！！回溯套循环
这区别于 之前的字符串全排列有 （那个是都是每一层中有数个可能）

66.分治法                              ----1763. 最长的美好子字符串
--------------------------------------------------------------------
我不允许没人看过分治的实现代码
下面给出一个例子 https://leetcode-cn.com/problems/longest-nice-substring/
class Solution {
    private int maxPos;
    private int maxLen;

    public String longestNiceSubstring(String s) {
        this.maxPos = 0;
        this.maxLen = 0;
        dfs(s, 0, s.length() - 1);
        return s.substring(maxPos, maxPos + maxLen);
    }

    public void dfs(String s, int start, int end) {
        if (start >= end) {
            return;
        }
        int lower = 0, upper = 0;
        for (int i = start; i <= end; ++i) {
            if (Character.isLowerCase(s.charAt(i))) {
                lower |= 1 << (s.charAt(i) - 'a');
            } else {
                upper |= 1 << (s.charAt(i) - 'A');
            }
        }
        if (lower == upper) {
            if (end - start + 1 > maxLen) {
                maxPos = start;
                maxLen = end - start + 1;
            }
            return;
        }
        int valid = lower & upper;  //取出成功配对的
        int pos = start;
        while (pos <= end) {
            start = pos;
            while (pos <= end && (valid & (1 << Character.toLowerCase(s.charAt(pos)) - 'a')) != 0) {  //若这里==0了 那么这个char便是上面没能配对成功的 从这里分开 //这里变大写还是小写倒是无所谓
                ++pos;
            }
            dfs(s, start, pos - 1);  //在没能成功配对的char分开了 可能会把配对好的一对也分开 所以继续dfs
            ++pos;
        }
    }
}


67.贪心的隐形应用(数学推理)            ----1414. 和为 K 的最少斐波那契数字数目
————————————————————————————————————————————————————————————————————————

68.单词各字符重组判断                                 ----49. 字母异位词分组
https://leetcode-cn.com/problems/group-anagrams/
————————————————————————————————————————————————————————————————————————
思路很简单的一题 但因我不知道记录字符而做不出来
因为HashMap的键是不能放int[]的

方法一：排序
由于互为字母异位词的两个字符串包含的字母相同，因此对两个字符串分别进行排序之后得到的字符串一定是相同的，故可以将排序之后的字符串作为哈希表的键。
妙啊 哈哈好简单的思路啊

方法二：计数
由于互为字母异位词的两个字符串包含的字母相同，因此两个字符串中的相同字母出现的次数一定是相同的，故可以将每个字母出现的次数使用字符串表示，作为哈希表的键。
由于字符串只包含小写字母，因此对于每个字符串，可以使用长度为 2626 的数组记录每个字母出现的次数。
需要注意的是，在使用数组作为哈希表的键时，不同语言的支持程度不同，因此不同语言的实现方式也不同。

还学会了
1.char[] array = str.toCharArray();
 String key = new String(array);
2.Map<String, List<String>> map = new HashMap<String, List<String>>();
  return new ArrayList<List<String>>(map.values());    // public List<List<String>> groupAnagrams(String[] strs) {}

多去看看构造方法吧

69.某种特殊题目用的sort（超级推）        ----75. 颜色分类
https://leetcode-cn.com/problems/sort-colors/
————————————————————————————————————————————————————————-
非常建议了解

70.数学推导出 动态规划               ----96. 不同的二叉搜索树
——————————————————————————————————————————————————————————
推导的思想

71.二叉树展开为链表            ----114. 二叉树展开为链表
——————————————————————————————————————————————————————-
看看大佬的递归方法 和官方的前指针方法

大佬代码!!! 这就是我想要的代码 压力马斯捏
class Solution {
    public void flatten(TreeNode root) {
        if (root == null) return;
        flatten(root.left);
        TreeNode right = root.right;
        root.right = root.left;
        root.left = null;
        while (root.right != null) {
            root = root.right;
        }
        flatten(right);
        root.right = right;
    }
}

72. return时列表转数组                    ----599. 两个列表的最小索引总和
————————————————————————————————————————————————————————————————————————————
例子   return list.toArray(new String[list.size()]);

不要  // return list.toArray(String[3] string); 不是这么写的


73. O(1) 时间插入、删除和获取随机元素         ----380. O(1) 时间插入、删除和获取随机元素
————————————————————————————————————————————————————————————————————————————————————————
    * 1.取随机整数值，在0到数组arr长度(不包含)的范围
    * ===
    *  Random random = new Random();
    *  int index = random.nextInt(arr.length());
    * ===
    *  int idx = (int) (Math.random() * arr.length());
——————————————————————————————————————————————————————————————————————————————————————
 * 2.优解是 变长数组（List） + 哈希表
 * 变长数组可以在 O(1) 的时间内完成获取随机元素操作，但是由于无法在 O(1) 的时间内判断元素是否存在，
 * 因此不能在 O(1) 的时间内完成插入和删除操作。哈希表可以在 O(1) 的时间内完成插入和删除操作，
 * 但是由于无法根据下标定位到特定元素，因此不能在 O(1)的时间内完成获取随机元素操作。为了满足插入、删除和获取随机元素操作的时间复杂度都是O(1)，
 * 需要将变长数组和哈希表结合，变长数组中存储元素，哈希表中存储每个元素在变长数组中的下标。
 *
 * 删除操作的重点在于将变长数组的最后一个元素移动到待删除元素的下标处，然后删除变长数组的最后一个元素。该操作的时间复杂度是 O(1)。



 74.移动窗口 遍历所有窗口的新方法                 ----6049. 含最多 K 个可整除元素的子数组
 ——————————————————————————————————————————————————————————————————————————————————
 滑动窗口，我常常是 1个for确定步长，另一个for确定起点，本题又要对窗口的每个位进行判断，我又得加一个for
 可以像下面代码一样
 1个for是起点，一个for移动，每次移动都记录，这样也可以遍历所有窗口

 75.水塘抽样算法!!!!                  ----382. 链表随机节点  ---398. 随机数索引
 —————————————————————————————————————————————————————————————————————————————

 76. 重复段分层                          ----38. 外观数列
 ————————————————————————————————————————————————————————————————————————————————————
 本题的重复段分层很好用
             int start = 0,pos = 0;
             while (pos<num.length())
             {
                 while (pos<num.length()&&num.charAt(pos)==num.charAt(start)) pos++;   //这个这个
                 sb.append(Integer.valueOf(pos-start)).append(num.charAt(start));
                 start=pos;
             }

 77.boolean和Boolean                     ----73. 矩阵置零
 ——————————————————————————————————————————————————————————————————————————————
区别
boolean是基本数据类型
Boolean是它的封装类

78.!!! 链表深复制（含支线）  ！！！hashMap<Node,Node> 妙用 由原节点领着前进        ---- 138. 复制带随机指针的链表
——————————————————————————————————————————————————————————————————————————
class Solution {
    Map<Node, Node> cachedNode = new HashMap<Node, Node>();

    public Node copyRandomList(Node head) {
        if (head == null) {
            return null;
        }
        if (!cachedNode.containsKey(head)) {
            Node headNew = new Node(head.val);
            cachedNode.put(head, headNew);
            headNew.next = copyRandomList(head.next);    //先是next一条路走到黑 然后才从后面连random的
            headNew.random = copyRandomList(head.random);
        }
        return cachedNode.get(head);
    }
}

79.寻找链表中点 + 链表逆序 + 合并链表     ----143. 重排链表
————————————————————————————————————————————————————————


80.链表 自顶向下归并排序！！！           ----148. 排序链表
————————————————————————————————————————————————————
  官方答案
  自顶向下归并排序！！！

  mid总是偏向右边 在sortList(head, mid);时
  会有
    if (head.next == tail) {
            head.next = null;
            return head;
        }
  从而恰掉右边
  脑内模拟一下会发现 传入的head和mid不会指向一个节点的（ mid总是偏向右边） 所以不必担心这种情况会卡住
  这答案非常巧妙！

  81.二叉树的右视图            -----199. 二叉树的右视图
  ——————————————————————————————————————————————————


82.螺旋矩阵                 ----54.螺旋矩阵
————————————————————————————————————————————————————
顺时针遍历m*n数组

83.！！！删除二叉搜索树中的节点         ----450. 删除二叉搜索树中的节点
——————————————————————————————————————————————————————————————
删除节点的方法 就是让新节点ntr原节点就行了


83.  遍历hashmap键值对的方法！！！
      ArrayList可以直接转为Integer[]
                                                         ----508. 出现次数最多的子树元素和
 ————————————————————————————————————————————————————————————————————————————————————————
 /*
 1.
 遍历hashmap的方法！！！
 http://t.csdn.cn/9hyOG
 本题出现了对hashmap键值对遍历的方法：

  HashMap<Integer,Integer> hashMap = new HashMap<>();
 Iterator<Map.Entry<Integer, Integer>> iterator = hashMap.entrySet().iterator();
         while (iterator.hasNext()) {
             Map.Entry<Integer, Integer> entry = iterator.next();
             int key = entry.getKey();  //num
             int val = entry.getValue(); //count
             }

 ================================================
 2.  ArrayList可以直接转为  Integer[] ,但不能直接变成int[]
 只能用for变成int[]

    ArrayList<Integer> list = new ArrayList<Integer>();
    Integer[] arr = list.toArray(new Integer[list.size()]);
  */



84.